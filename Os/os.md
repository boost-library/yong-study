# 운영체제

- [커널](#커널)
- [이중모드와 시스템 호출](#이중모드와-시스템-호출)
- [pcb](#pcb)
- [문맥 교환](#문맥-교환)
- [프로세스의 메모리 영역](#프로세스의-메모리-영역)

- [프로세스 상태](#프로세스-상태)
- [프로세스 생성 기법](#프로세스-생성-기법)
- [스레드의 구성 요소](#스레드의-구성-요소)
- [프로세스 우선순위](#프로세스-우선순위)
- [스케줄링 큐](#스케줄링-큐)
- [선점형(Preemptive)과 비선점형 스케줄링(Non-preemptive)](#선점형과-비선점형-스케줄링)

- [프로세스 동기화](#프로세스-동기화)
- [공유 자원과 임계 구역](#공유-자원과-임계-구역)
- [동기화 기법](#동기화-기법)

- [교착상태](#교착상태)
- [스와핑](#스와핑)
- [연속 메모리 할당 방식](#연속-메모리-할당-방식)
- [외부 단편화](#외부-단편화)

- [페이징](#페이징)
- [페이지 테이블](#페이지-테이블)
- [프로세스 테이블 베이스 레지스터](#프로세스-테이블-베이스-레지스터)
- [tlb](#tlb)
- [페이징에서의 주소 변환](#페이징에서의-주소-변환)
- [페이지 테이블 엔트리](#페이지-테이블-엔트리)
- [요구 페이징](#요구-페이징)
- [페이지 교체 알고리즘](#페이지-교체-알고리즘)
- [스래싱](#스래싱)
- [프레임 할당](#프레임-할당)

- [페이징의 이점](#페이징의-이점)
- [계층적 페이지](#계층적-페이지)
- [파일 시스템](#파일-시스템)


### 커널

<details>
<summary></summary>

운영체제의 핵심 서비스를 담당하는 부분을 커널(kernal)
- 프로세스 관리
- 자원 접근 및 할당
- 파일 시스템 관리

</details>


### 이중모드와 시스템 호출

<details>
<summary></summary>

CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식

- 사용자 모드
    - 운영체제 서비스를 제공받을 수 없는 실행 모드
    - 커널 영역의 코드를 실행할 수 없는 실행 모드
    - 자원 접근 불가
- 커널 모드
    - 운영체제의 서비스를 제공받을 수 있는 실행 모드
    - 자원 접근을 비롯한 모든 명령어 실행 가능

시스템 호출     
- 커널 모드로 전환하여 실행하기 위해 호출
- 일종의 소프트웨어 인터럽트

</details>

### pcb

<details>
<summary></summary>

빠르게 번갈아 수행되는 프로세스들을 관리하기 위해 사용하는 자료구조 
운영체제는 커널 영역에 적재된 PCB를 보고 프로세스를 관리

PCB에 담기는 대표적인 정보
- pid
- 레지스터 값
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 정보
- 사용한 파일과 입출력장치 정보

</details>


### 문맥 교환

<details>
<summary></summary>

실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다
- 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을
- 문맥  교환(context switching)이라 한다

</details>

### 프로세스의 메모리 영역

<details>
<summary></summary>

크게 코드 영역(=텍스트 영역), 데이터 영역, 힙 영역, 스택영역으로 프로세스는 사용자 영역에 저장

실행되는 동안 크기가 고정적 - 정적 할당 영역
- 코드 영역
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 read-only
- 데이터 영역
    - 프로그램 실행동안 유지할 데이터
    - 전역변수

실행 되는 동안 크기가 가변적 - 동적 할당 영역
- 힙 영역
    - 프로그래머가 직접 할당할 수 있는 저장공간
- 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - 매개변수, 지역변수
- 메모리간 충돌 방지를 위해 힙, 스택영역은 반대 방향으로 주소 할당

</details>

### 프로세스 상태

<details>
<summary></summary>

- 생성
- 준비
- 실행
    - 타이머 인터럽트 발생 시(할당된 시간 모두 사용 시) 준비상태
- 대기
- 종료

</details>

### 프로세스 생성 기법

<details>
<summary></summary>

시스템 호출

- fork : 자식 프로세스 생성
- exec : 자신의 메모리 공간을 다른 프로그램으로 교체(복사된 부모 프로세스의 메모리 영역과 별개)

</details>

### 스레드의 구성 요소

<details>
<summary></summary>

스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등

실행에 필요한 최소한의 정보

프로세스를 이루는 모든 스레드들은 그 프로세스의 자원을 공유할 수 있다

</details>

### 프로세스 우선순위

<details>
<summary></summary>

I/O Bound Process, 입출력 집중 프로세스 > CPU Bound Process, CPU 집중 프로세스

I/O Bound Process 대기 상태에 더 많이 존재하기 떄문

</details>

### 스케줄링 큐

<details>
<summary></summary>

특정 자원(cpu,hdd, i/o devcie)을 이용하고 싶어하는 프로세스들을 큐에 삽입해서 자원을 이용하도록 만듦

</details>

### 선점형과 비선점형 스케줄링

<details>
<summary></summary>

선점형 스케줄링

현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당

- 장점
    - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능
- 단점
    - 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

비선점형 스케줄링

현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기

- 장점
    - 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점
    - 모든 프로세스가 골고루 자원을 이용하기 어렵다


</details>


### 프로세스 동기화

<details>
<summary></summary>

실행 순서 제어: 프로세스를 올바른 순서대로 실행하기

상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기

</details>

### 공유 자원과 임계 구역

<details>
<summary></summary>

공유 자원: 여러 프로세스 혹은 스레드가 공유하는 자원

임계 구역: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역

</details>


### 동기화 기법

<details>
<summary></summary>

뮤텍스 락
세마포어
모니터

</details>


### 교착상태

<details>
<summary></summary>
 
일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상

발생 조건
- 상호 배제
- 점유와 대기
- 비선점
- 환형 대기

 해결 방법
- 교착 상태 예방
- 교착 상태 회피
- 교착 상태 검출 후 회복
- 교착 상태 무시

</details>

### 스와핑

<details>
<summary></summary>

현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역(스왑 영역)으로 쫓아내고, 그렇게 생긴 빈 공간에 새 프로세스 적재

</details>

### 연속 메모리 할당 방식

<details>
<summary></summary>

프로세스는 메모리의 빈 공간에 할당

최초 적합, 최적 적합, 최악 적합

</details>

### 외부 단편화

<details>
<summary></summary>

- 프로세스들이 실행되고 종료되길 반복하며 메모리 사이에 빈 공간 발생

- 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

해결 방법

- 메모리 압축

- 가상 메모리 기법, 페이징

</details>

### 페이징

<details>
<summary></summary>

- 페이징은 프로세스를 일정한 크기로 자르고, 이를 메모리에 불연속적으로 할당하여 외부 단편화를 해결한다
- 프로세스의 논리 주소 공간을 페이지(page)라는 일정 단위로 자르고,
- 메모리의 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 일정한 단위로 자른 뒤
- 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징에서의 스와핑을 통해 물리 메모리보다 큰 프로세스도 실행 가능

</details>

### 페이지 테이블

<details>
<summary></summary>

페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
- CPU는 그저 논리 주소를 순차적으로 실행하면 될 뿐
- 내부 단편화 발생 가능

</details>

### 프로세스 테이블 베이스 레지스터

<details>
<summary></summary>

- 프로세스마다 페이지 테이블이 있고, 각 페이지 테이블은 CPU내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킨다(저장).
- 페이지 테이블이 메모리에 있다면 메모리 접근 시간이 두배로 걸리는 문제가 생김

</details>

### tlb

<details>
<summary></summary>

- CPU 곁에 페이지 테이블의 캐시 메모리
- 페이지 테이블의 일부를 가져와 저장하여 불필요한 메모리 접근을 줄일 수 있다

</details>

### 페이징에서의 주소 변환

<details>
<summary></summary>

- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 페이징 시스템에서의 논리 주소
- 페이지 번호(page number)와 변위(offset)
- <페이지 번호, 변위>로 이루어진 논리 주소는 페이지 테이블을 통해 <프레임 번호, 변위>로 이루어진 물리주소로 변환

</details>

### 페이지 테이블 엔트리

<details>
<summary></summary>

- 유효비트
    - 현재 해당 페이지에 접근 가능한지 여부

- 보호 비트
    - 페이지 보호 기능을 위해 존재하는 비트

- 참조 비트
    - CPU가 이 페이지에 접근한 적이 있는지 여부

- 수정 비트(=dirty bit)
    - CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부

</details>

### 요구 페이징

<details>
<summary></summary>

처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법

</details>


### 페이지 교체 알고리즘

<details>
<summary></summary>

당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 하는데 어떤 페이지를 내보내는 방법(알고리즘)이 페이지 교체 알고리즘

페이지 폴트가 적은 알고리즘이 좋은 페이지 교체 알고리즘

- FIFO 페이지 교체 알고리즘
    - 모리에 가장 먼저 올라온 페이지부터 내보내는 방식 
- FIFO 페이지 교체 알고리즘_보완책
    - 2차 기회(second-chance) 페이지 교체 알고리즘
- 최적 페이지 교체 알고리즘
    - 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
- LRU(Least-Recently-Used) 페이지 교체 알고리즘
    - 가장 오래 사용되지 않은 페이지 교체

</details>

### 스래싱

<details>
<summary></summary>

프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제

</details>

### 프레임 할당

<details>
<summary></summary>

정적 할당 방식
- 균등 할당(equal allocation)
- 비례 할당(proportional allocation)

동적 할당 방식
- 작업 집합 모델(Working set Model)
- 페이지 폴트 빈도

</details>

### 페이징의 이점

<details>
<summary></summary>

페이징 → 외부 단편화 해결 가능, 프로세스 간 페이지 공유 가능(쓰기 시 복사, 공유 라이브러리)

- 쓰기 시 복사
    - 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴(쓰기 작업 없다면 이 상태 유지)
- 프로세스 간 기본적으로는 자원을 공유 ❌ 
    → 부모 프로세스/자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시 해당 페이지는 별도의 공간으로 복제(프로세스 생성 시간 절약, 메모리 절약) 

</details>

### 계층적 페이지

<details>
<summary></summary>

페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식 
- 계층이 많을 경우, 페이지 폴트가 발생하여 반드시 좋은 것은 ❌

</details>

### 파일 시스템

<details>
<summary></summary>

파일 시스템이 파일과 디렉터리를 보조기억장치에 할당하고 접근하는 기법

- 파티셔닝
    - 저장 장치의 논리적인 영역을 구획하는 작업(파티션)

- 포매팅
    - 파일 시스템을 설정

파일을 보조기억장치에 할당하는 두 가지 방법
- 파일 할당
    - 연속할당
    - 불연속 할당
        - 연결 할당
        - 색인 할당

FAT 파일 시스템
- 연결 할당 기반 파일 시스템
- FAT가 메모리에 캐시될 경우 느린 임의 접근 속도 개선 가능

유닉스 파일 시스템
- 색인 할당 기반 파일 시스템

</details>