# 운영체제

- [커널](#커널)
- [이중모드와 시스템 호출](#이중모드와-시스템-호출)
- [pcb](#pcb)
- [문맥 교환](#문맥-교환)
- [프로세스의 메모리 영역](#프로세스의-메모리-영역)

- [프로세스 상태](#프로세스-상태)
- [프로세스 생성 기법](#프로세스-생성-기법)
- [스레드의 구성 요소](#스레드의-구성-요소)
- [프로세스 우선순위](#프로세스-우선순위)
- [스케줄링 큐](#스케줄링-큐)
- [선점형(Preemptive)과 비선점형 스케줄링(Non-preemptive)](#선점형과-비선점형-스케줄링)

### 커널

<details>
<summary></summary>

운영체제의 핵심 서비스를 담당하는 부분을 커널(kernal)
- 프로세스 관리
- 자원 접근 및 할당
- 파일 시스템 관리

</details>


### 이중모드와 시스템 호출

<details>
<summary></summary>

CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식

- 사용자 모드
    - 운영체제 서비스를 제공받을 수 없는 실행 모드
    - 커널 영역의 코드를 실행할 수 없는 실행 모드
    - 자원 접근 불가
- 커널 모드
    - 운영체제의 서비스를 제공받을 수 있는 실행 모드
    - 자원 접근을 비롯한 모든 명령어 실행 가능

시스템 호출     
- 커널 모드로 전환하여 실행하기 위해 호출
- 일종의 소프트웨어 인터럽트

</details>

### pcb

<details>
<summary></summary>

빠르게 번갈아 수행되는 프로세스들을 관리하기 위해 사용하는 자료구조 
운영체제는 커널 영역에 적재된 PCB를 보고 프로세스를 관리

PCB에 담기는 대표적인 정보
- pid
- 레지스터 값
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 정보
- 사용한 파일과 입출력장치 정보

</details>


### 문맥 교환

<details>
<summary></summary>

실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다
- 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을
- 문맥  교환(context switching)이라 한다

</details>

### 프로세스의 메모리 영역

<details>
<summary></summary>

크게 코드 영역(=텍스트 영역), 데이터 영역, 힙 영역, 스택영역으로 프로세스는 사용자 영역에 저장

실행되는 동안 크기가 고정적 - 정적 할당 영역
- 코드 영역
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 read-only
- 데이터 영역
    - 프로그램 실행동안 유지할 데이터
    - 전역변수

실행 되는 동안 크기가 가변적 - 동적 할당 영역
- 힙 영역
    - 프로그래머가 직접 할당할 수 있는 저장공간
- 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - 매개변수, 지역변수
- 메모리간 충돌 방지를 위해 힙, 스택영역은 반대 방향으로 주소 할당

</details>

### 프로세스 상태

<details>
<summary></summary>

- 생성
- 준비
- 실행
    - 타이머 인터럽트 발생 시(할당된 시간 모두 사용 시) 준비상태
- 대기
- 종료

</details>

### 프로세스 생성 기법

<details>
<summary></summary>

시스템 호출

- fork : 자식 프로세스 생성
- exec : 자신의 메모리 공간을 다른 프로그램으로 교체(복사된 부모 프로세스의 메모리 영역과 별개)

</details>

### 스레드의 구성 요소

<details>
<summary></summary>

스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등

실행에 필요한 최소한의 정보

프로세스를 이루는 모든 스레드들은 그 프로세스의 자원을 공유할 수 있다

</details>

### 프로세스 우선순위

<details>
<summary></summary>

I/O Bound Process, 입출력 집중 프로세스 > CPU Bound Process, CPU 집중 프로세스

I/O Bound Process 대기 상태에 더 많이 존재하기 떄문

</details>

### 스케줄링 큐

<details>
<summary></summary>

특정 자원(cpu,hdd, i/o devcie)을 이용하고 싶어하는 프로세스들을 큐에 삽입해서 자원을 이용하도록 만듦

</details>

### 선점형과 비선점형 스케줄링

<details>
<summary></summary>

선점형 스케줄링

현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당

- 장점
    - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능
- 단점
    - 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

비선점형 스케줄링

현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기

- 장점
    - 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점
    - 모든 프로세스가 골고루 자원을 이용하기 어렵다


</details>

