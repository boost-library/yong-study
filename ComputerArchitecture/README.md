# 컴퓨터 구조

- [필요성](#필요성)
- [데이터](#데이터)
- [명령어](#명령어)
- [컴퓨터의 네 가지 핵심 부품](#컴퓨터의-네-가지-핵심-부품)
- [메인보드](#메인보드)
- [시스템 버스](#시스템-버스)
- [비트](#비트)
- [워드](#워드)
- [인코딩,디코딩](#인코딩,디코딩)
- [아스키 코드](#아스키-코드)
- [유니코드&utf-8 인코딩](#유니코드)
- [컴파일 언어](#컴파일-언어)
- [인터프리트 언어](#인터프리트-언어)
- [명령어의 구조](#명령어의-구조)
- [어셈블리어](#어셈블리어)
- [유효 주소, 명령어 주소 지정 방식](#유효-주소,-명령어-주소-지정-방식)

- [c언어의 컴파일 과정](#c언어의-컴파일-과정)
- [ALU 입출력정보](#alu-입출력정보)
- [제어장치 입출력정보](#제어장치-입출력정보)
- [프로그램 카운터](#프로그램-카운터)
- [명령어 레지스터](#명령어-레지스터)
- [메모리 주소 레지스터](#메모리-주소-레지스터)
- [메모리 버퍼 레지스터](#메모리-버퍼-레지스터)
- [플래그 레지스터](#플래그-레지스터)
- [범용 레지스터](#범용-레지스터)
- [베이스 레지스터](#베이스-레지스터)

- [명령어 사이클 구조](#명령어-사이클-구조)
- [인터럽트 종류](#인터럽트-종류)
- [하드웨어 인터럽트의 순서](#하드웨어-인터럽트의-순서)
- [클럭신호](#클럭신호)
- [CPU 속도를 빠르게 하는 방법](#cpu-속도를-빠르게-하는-방법)
- [코어와 프로세서 멀티코어 프로세서](#코어와-프로세서-멀티코어-프로세서)
- [스레드의 개념과 종류](#스레드의-개념과-종류)

- [명령어 병렬 처리기법](#명령어-병렬-처리기법)
- [명령어 파이프라인](#명령어-파이프라인)
- [명령어가 처리되는 과정](#명령어가-처리되는-과정)
- [파이프라인 위험](#파이프라인-위험)
- [슈퍼스칼라](#슈퍼스칼라)
- [비순차적 명령어 처리](#비순차적-명령어-처리)
- [명령어 집합](#명령어-집합)
- [cisc](#cisc)
- [risc](#risc)

- [RAM의 종류](#ram의-종류)
- [물리주소와 논리주소](#물리주소와-논리주소)
- [물리 주소와 논리 주소의 변환](#물리-주소와-논리-주소의-변환)
- [베이스 레지스터](#베이스-레지스터)
- [캐시 메모리](#캐시-메모리)
- [참조 지역성의 원리](#참조-지역성의-원리)
- [하드 디스크의 데이터 접근 과정](#하드-디스크의-데이터-접근-과정)
- [플래시 메모리의 종류와 저장 단위](#플래시-메모리의-종류와-저장-단위)
- [플래시 메모리 저장 단위 페이지의 상태](#플래시-메모리-저장-단위-페이지의-상태)

- [RAID](#raid)
- [장치 컨트롤러의 역할과 구조](#장치-컨트롤러의-역할과-구조)
- [장치 드라이버](#장치-드라이버)
- [프로그램 입출력](#프로그램-입출력)
- [인터럽트 기반 입출력](#인터럽트-기반-입출력)
- [DMA 입출력](#dma-입출력)
- [입출력 버스](#입출력-버스)

### 필요성

<details>
<summary></summary>
프로그래밍 언어의 문법만으로는 해결하기 어려운 문제들을 해결 가능하며 성능, 용량, 비용을 고려한 개발이 가능하다
</details>

### 데이터

<details>
<summary></summary>

- 숫자, 문자, 이미지와 같은 정적인 정보

- 컴퓨터와 주고받는/내부에 저장된 정보를 데이터라 통칭하기도

- 0과 1로 숫자,문자를 표현하는 방법
</details>

### 명령어

<details>
<summary></summary>

- 컴퓨터를 실질적으로 움직이는 정보

</details>

### 컴퓨터의 네 가지 핵심 부품

<details>
<summary></summary>

#### CPU

구성요소

- ALU(산술논리연산장치): 계산기
- 제어장치: 제어신호를 내보내고, 명령어를 해석하는 장치
- 레지스터: CPU 내부의 작은 저장장치

CPU는 메모리에 저장된 값을 읽어들이고, 해석하고, 실행하는 장치

#### 메모리

구성요소

- RAM
- ROM

프로그램이 실행되기 위해서는 메모리에 저장되어 있어야, 메모리는 실행되는 프로그램(프로세스)의 명령어와 데이터를 저장
주소를 통해 내가 원하는 명령어 혹은 데이터가 어디에 위치해 있는지 알 수 있다.

#### 보조기억장치

메모리는 실행될 정보를 저장, 보조기억장치는 보관할 정보를 저장

#### 입출력장치

</details>

### 메인보드

<details>
<summary></summary>

- 메인보드에 연결된 컴퓨터의 4가지 핵심 부품끼리 시스템 버스를 통해서 정보를 주고받음

</details>

### 시스템 버스

<details>
<summary></summary>
구성 요소
- 주소 버스: 주소를 주고 받는 통로
- 데이터 버스: 명령어와 데이터를 주고받는 통로
- 제어 버스: 제어신호를 주고받는 통로
</details>

### 비트

<details>
<summary></summary>
비트(bit): 0과 1을 표현하는 가장 작은 정보 단위
</details>

### 워드

<details>
<summary></summary>
CPU가 한 번에  처리할 수 있는 정보의 크기 단위
</details>

### 인코딩,디코딩

<details>
<summary></summary>
인코딩: 코드화하는 과정
디코딩: 코드를 해석하는 과정
</details>

### 아스키 코드

<details>
<summary></summary>
초창기 문자 집합 중 하나

7비트로 하나의 문자 표현(2^7= 128개의 문자 표현)
8비트 중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)

</details>

### 유니코드

<details>
<summary></summary>

유니코드

- 통일된 문자 집합

- 한글, 영어, 화살표와 같은 특수 문자, 심지어 이모티콘까지

- 현대 문자 표현에 있어 매우 중요한 위치

utf-8 인코딩

- 유니코드 인코딩 방법.
- 가변 길이 인코딩: 인코딩 결과가 1바이트~4바이트
- 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값(유니코드 코드 포인트)에 따라 다름
</details>

### 컴파일 언어

<details>
<summary></summary>

- 컴파일 언어로 작성된 소스 코드는 컴파일러에 의해 저급 언어(어센블리어)로 변환되고(컴파일), 컴파일 결과로 저급 언어인 목적(원시) 코드가 생성

- 컴파일러가 소스코드 전체를 훑어보면서(한줄씩❌) 오류는 없는지, 사용되지 않는 변수, 최적화 여부 등을 따져본 뒤 목적 코드로 컴파일

- 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않음

</details>

### 인터프리트 언어

<details>
<summary></summary>

- 인터프리터에 의해 한 줄씩 실행
- 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요 ❌
- 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행

</details>

### 어셈블리어

<details>
<summary></summary>

0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어(기계어보다 한단계 위의 저급언어)

</details>

### 명령어의 구조

<details>
<summary></summary>

명령어는 연산 코드와 오퍼랜드로 구성된다.

- 오퍼랜드: 연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치(주로 저장되는 정보), 오퍼랜드 필드를 주소 필드(메모리 주소, 레지스터)라고 하기도 한다.

- 왜 굳이 오퍼랜드에 저장된 위치를 사용할까?
  명령어 내에서 표현할 수 있는 데이터의 크기가 제한되기 때문

</details>

### 유효 주소, 명령어 주소 지정 방식

<details>
<summary></summary>

- 유효 주소: 연산에 사용할 데이터가 저장된 위치

명령어 주소 지정 방식

- 연산에 사용할 데이터가 저장된 위치를 찾는 방법
- 유효 주소를 찾는 방법
</details>

### c언어의 컴파일 과정

<details>
<summary></summary>

전처리기(전처리) -> 컴파일러(컴파일) -> 어셈블러(어셈블) -> 링커(링킹)

어셈블 과정을 거쳐 목적파일이 되며 링킹을 거쳐 실행 파일이 된다.

</details>

### alu 입출력정보

<details>
<summary></summary>

입력: 피연산자(레지스터), 제어신호(제어장치)
출력: 계산 결괏 값(레지스터), 플래그(플레그 레지스터)

</details>

### 제어장치 입출력정보

<details>
<summary></summary>

입력

- 클럭 신호(클럭 주기에 맞춰 컴퓨터의 모든 부품을 움직이게 하는 시간 단위)
- 해석할 명령어
- 플래그
- 제어신호

출력

- CPU 내부에 전달하는 제어신호(레지스터, ALU)
- CPU 외부에 전달하는 제어신호(입출력, 메모리)

</details>

### 프로그램 카운터

<details>
<summary></summary>

메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어의 주소, Instruction Pointor라고 부르는 CPU도 있음)

</details>

### 명령어 레지스터

<details>
<summary></summary>

해석할 명령어(방금 메모리에서 읽어 들인 명령어 - 제어장치가 해석)

</details>

### 메모리 주소 레지스터

<details>
<summary></summary>

메모리의 주소를 저장(CPU가 읽어 들이고자 하는 주소를 주소 버스로 보낼 떄 거치는 레지스터)

</details>

### 메모리 버퍼 레지스터

<details>
<summary></summary>

메모리와 주고받을 값(데이터와 명령어, CPU가 정보를 데이터 버스로 주고받을 떄 거치는 레지스터)

</details>

### 플래그 레지스터

<details>
<summary></summary>

연산 결과 또는 CPU 상태에 대한 부가적인 정보

</details>

### 범용 레지스터

<details>
<summary></summary>

다양하고 일반적인 상황에서 자유롭게(주소, 명령어, 데이터…) 사용

</details>

### 스택 포인터

<details>
<summary></summary>

스택의 꼭대기를 가리킴

</details>

### 베이스 레지스터

<details>
<summary></summary>

기준 주소 저장

</details>

### 명령어 사이클 구조

<details>
<summary></summary>

- 메모리에 저장되어 있는 값을 CPU 내부(레지스터)로 갖고 와야함 → 인출

  - 인출하는 주기: 인출사이클

- 인출했다면 저장되어 있는 값(명령어)을 실행해야

  - 실행하는 주기: 실행사이클

- 간접 사이클이 추가 될 수 있다.

  - 간접주소지정방식으로 인한 메모리 접근의 추가 발생

- 인터럽트 발생 시, 실행사이클 마치고 진행

  - 인터럽트 사이클

  </details>

### 인터럽트 종류

<details>
<summary></summary>

동기 인터럽트(예외): CPU가 예기치 못한 상황을 접했을 떄 발생

비동기 인터럽트(하드웨어 인터럽트): 주로 입출력장치에 의해 발생

</details>

### 하드웨어 인터럽트의 순서

<details>
<summary></summary>

1. 입출력장치 인터럽트 요청 신호 -> CPU
2. CPU는 실행 사이클이 끝나고 인출하기 전 항상 인터럽트 여부 확인
3. CPU가 인터럽트 요청 확인 후, 인터럽트 플래그를 통해 인터럽트 요청신호 받아들일지 말지 여부 확인
4. 인터럽트를 받아들인다면 CPU는 지금까지의 작업을 메모리(스택영역) 백엄
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
6. 프로그램이 끝나면 백업해 둔 데이터를 기존 CPU 레지스터에 복구

</details>

### 클럭신호

<details>
<summary></summary>

컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위

</details>

### cpu 속도를 빠르게 하는 방법

<details>
<summary></summary>

- 클럭 신호를 빠르게 한다면
- 코어 수를 늘리는 방법(’듀얼 코어’, ‘멀티 코어’, …)
- 스레드 수를 늘리는 방법(’멀티 스레드’, ..)

</details>

### 코어와 프로세서 멀티코어 프로세서

<details>
<summary></summary>

"코어"는 명령을 실행할 수 있는 CPU 내의 처리 장치
"프로세서"는 하나 이상의 코어로 구성될 수 있는 전체 CPU 칩을 의미
멀티코어 프로세서: 여러 개의 코어를 포함한 CPU

</details>

### 스레드의 개념과 종류

<details>
<summary></summary>

간단하게는 스레드란 ‘실행 흐름의 단위’

- 하드웨어 스레드

  - 하나의 코어가 동시에 처리하는 명령어 단위
  - 멀티스레드 프로세서를 설계하는 일은 매우 복잡하지만 가장 큰 핵심은 레지스터
  - 하나의 명령어를 실행하기 위해서 꼭 필요한 레지스터들을 하나의 코어가 여러개 갖고 있다면 멀티 스레드 프로세서를 설계할 수 있다.
  - 메모리에 저장되어있는(실행) 프로그램이 느끼기에 몇 개의 CPU가 있는지는 하드웨어 스레드 갯수만큼 있다는 점에서 논리 프로세서

- 소프트웨어 스레드
  - 하나의 프로그램에서 독립적으로 실행되는 단위
    - 싱글스레드: 한 프로그램이 하나의 실행 흐름만 가지고 순차적으로 실행
    - 멀티스레드: 하나의 프로그램에서 동시에 2개 이상의 영역이 실행

</details>

### 명령어 병렬 처리기법

<details>
<summary></summary>

- 명령어 파이프라이닝
- 슈퍼스칼라 기법
- 비순차적 명령어 처리

</details>

### 명령어 파이프라인

<details>
<summary></summary>

여러개의 명령어를 겹처서 실행하는 방법

</details>

### 명령어가 처리되는 과정

<details>
<summary></summary>

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

</details>

### 파이프라인 위험

<details>
<summary></summary>

명령어 파이프라인이 성능 향상에 실패(병렬로 파이프라인이 제대로 동작하지 않는)하는 경우
데이터 위험: 명령어 간의 의존성에 의해 야기
제어 위험: 갑작스러운 PC의 변화
구조적 위험: 서로 다른 명령어가 같은 CPU 부품(ALU, 레지스터)를 쓰려고 할 떄

</details>

### 슈퍼스칼라

<details>
<summary></summary>

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조

</details>

### 비순차적 명령어 처리

<details>
<summary></summary>

파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법

</details>

### 명령어 집합

<details>
<summary></summary>

CPU가 이해할 수 있는 명령어들의 모음

</details>

### cisc

<details>
<summary></summary>

- 복잡한 다양한 가변 길이 명령어 집합을 활용하는 컴퓨터(CPU)
- EX)x86, x86-64
- 명령어 파이프라닝에 불리

</details>

### risc

<details>
<summary></summary>

- 단순하고 적은 수의 고정 길이 명령어 집합을 활용하는 컴퓨터(CPU)
- EX) ARM
- 명령어 파이프라닝에 유리
- 더 많은 명령어로 프로그램을 동작

</details>

### ram의 종류

<details>
<summary></summary>

- DRAM
  - 저장된 데이터가 동적으로 사라지는 RAM
- SRAM
  - 캐시 메모리에서 사용되는 RAM
- SDRAM
  - 클럭 신호와 동기화된 DRAM
- DDR SDRAM
  - 대역폭을 넓혀 만든 SDRAM

</details>

### 물리주소와 논리주소

<details>
<summary></summary>

- 물리주소: 메모리 입장에서 바라본 주소
- 논리주소: CPU와 실행중인 프로그램 입장에서 바라본 주소
- 논리 주소: 프로그램의 시작점(기준 주소)으로부터 떨어진 거리

</details>

### 물리 주소와 논리 주소의 변환

<details>
<summary></summary>

- MMU(메모리 관리 장치)에 의해 논리 주소와 베이스 레지스터 값(프로그램의 기준 주소)을 더하여 논리 주소를 물리 주소로 변환

</details>

### 한계 레지스터

<details>
<summary></summary>

- 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음

</details>

### 베이스 레지스터

<details>
<summary></summary>

- 베이스 레지스터: 프로그램의 가장 작은 물리 주소(프로그램의 첫 물리 주소)를 저장하는 셈

</details>

### 캐시 메모리

<details>
<summary></summary>

- CPU와 메모리 사이에 위치한, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치

</details>

### 참조 지역성의 원리

<details>
<summary></summary>

CPU가 메모리에 접근할 떄의 주된 경향을 바탕으로 만들어진 원리

- CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향
- CPU는 접근한 메모리 공간 근처를 접근하려는 경향

</details>

### 하드 디스크의 데이터 접근 과정

<details>
<summary></summary>

- 탐색 시간
- 회전 지연
- 전송 시간

</details>

### 플래시 메모리의 종류와 저장 단위

<details>
<summary></summary>

종류

- 1 비트를 저장할 수 있는 플래시 메모리: SLC
- 2 비트를 저장할 수 있는 플래시 메모리: MLC
- 3 비트를 저장할 수 있는 플래시 메모리: TLC
- 4 비트를 저장할 수 있는 플래시 메모리: QLC

단위

- 셀 -> MB, GB, TB가 됨
- 셀들이 모여 페이지
- 페이지가 모여 블록

</details>

### 플래시 메모리 저장 단위 페이지의 상태

<details>
<summary></summary>

- Free 상태: 저장 가능
- Valid 상태: 유효한 데이터를 저장하고 있음
- Invalid: 쓰레기값

플레시 메모리는 하드 디스크와 달리 덮어쓰기가 불가능

플레시 메모리의 읽/쓰 단위는 삭제 단위와 다르다

- 읽/쓰는 페이지 단위
- 삭제는 블록단위
  => 블록 간 데이터 수정 시, 가비지 컬렉션에 의해 유효한 페이지들만 새로운 블록으로 복사, Invalid 상태의 블록을 삭제

</details>

### raid

<details>
<summary></summary>

데이터의 안전성 혹은 높은 성능을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술

</details>

### 장치 컨트롤러의 역할과 구조

<details>
<summary></summary>

장치 컨트롤러의 역할

- CPU와 입출력장치의 통신 중개
- 오류검출
- 데이터 버퍼링

장치 컨트롤러의 구조

- 데이터 레지스터
  - CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터(버퍼의 역할)
- 상태 레지스터
  - 상태 정보 저장
- 제어 레지스터
  - 입출력장치가 수행할 내용에 대한 제어 정보

</details>

### 장치 드라이버

<details>
<summary></summary>

장치 컨트롤러의 동작을 감지하고 제어하는 프로그램

</details>

### 프로그램 입출력

<details>
<summary></summary>

하드 디스크 컨트롤러의 특정 레지스터에 입출력 명령어로서 입출력 작업을 수행하는 것이 프로그램 입출력 방식

- CPU가 장치 컨트롤러의 레지스터 값들을 알기 위한 방법으로 메모리 맵 입출력 & 고립형 입출력이 있다

메모리 맵 입출력

- 메모리에 접근하기 위한 주소공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법

고립형 입출력

- 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법

</details>

### 인터럽트 기반 입출력

<details>
<summary></summary>

동시다발적인 인터럽트

- 많은 입출력장치의 장치 컨트롤러들이 CPU에게 인터럽트 요청 신호를 보낼 떄 순차적으로 처리 될 수 도있고
  - 플래그 레지스터 속 인터럽트 비트 비활성화 한 경우
- NMI 처럼 중요한 인터럽트 경우 우선순위가 높은 인터럽트를 먼저 처리해야 하는 경우가 있다

</details>

### dma 입출력

<details>
<summary></summary>

CPU를 거치지 않고 입출력장치와 메모리간의 데이터를 직접적으로 주고받는하는 입출력 방식

</details>

### 입출력 버스

<details>
<summary></summary>

DMA 컨트롤러가 시스템 버스를 (불필요하게)이용하는 것을 방지하기 위해 등장

</details>
